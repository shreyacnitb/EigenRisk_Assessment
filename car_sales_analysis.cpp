#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <unordered_map>
#include <map>
#include <algorithm>
#include <iomanip>
#include <cstdlib>
using namespace std;

// fast check for prefix
inline bool starts_with(const string &s, const string &pref) {
    return s.size() >= pref.size() && s.compare(0, pref.size(), pref) == 0;
}

// return substring of the nth field (0-based) split by tab.
// If not found, returns empty string.
string get_field_n(const string &line, size_t n) {
    size_t start = 0;
    size_t field = 0;
    size_t len = line.size();
    for (;;) {
        if (field == n) {
            // find end
            size_t end = line.find(',', start);
            if (end == string::npos) end = len;
            return line.substr(start, end - start);
        }
        size_t next = line.find(',', start);
        if (next == string::npos) return string();
        start = next + 1;
        ++field;
        if (start >= len) return string();
    }
}

int main(int argc, char** argv) {

    if (argc < 2) {
        cerr << "Usage: " << argv[0] << " <world_car_sales_1m.csv>\n";
        return 1;
    }
    const string filename = argv[1];
    ifstream in(filename);
    if (!in.is_open()) {
        cerr << "Error: cannot open file " << filename << "\n";
        return 1;
    }

    string header;
    if (!getline(in, header)) {
        cerr << "Error: empty file or could not read header\n";
        return 1;
    }

    unordered_map<string, int> h_idx; // Map header name -> index
    {
        int idx = 0;
        size_t pos = 0, len = header.size();
        while (pos <= len) {
            size_t nxt = header.find(',', pos);
            if (nxt == string::npos) nxt = len;
            string col = header.substr(pos, nxt - pos);
            h_idx[col] = idx++;
            if (nxt == len) break;
            pos = nxt + 1;
        }
    }

    // required columns
    vector<string> required = {"sale_date", "country", "region", "manufacturer", "sale_price_usd"};
    for (auto &c : required) {
        if (h_idx.find(c) == h_idx.end()) {
            cerr << "Error: required column '" << c << "' not found in header\n";
            return 1;
        }
    }
    int idx_date = h_idx["sale_date"];
    int idx_country = h_idx["country"];
    int idx_region = h_idx["region"];
    int idx_manufacturer = h_idx["manufacturer"];
    int idx_price = h_idx["sale_price_usd"];

    // Aggregation variables
    uint64_t audi_china_2025 = 0;
    long double bmw_revenue_2025 = 0.0L;
    unordered_map<string, long double> europe_revenue_by_country;
    europe_revenue_by_country.reserve(64);

    string line;
    size_t line_no = 1;
    while (getline(in, line)) {
        ++line_no;
        if (line.empty()) continue;

        // Fetch manufacturer first, ignore if not Audi/BMW
        string manufacturer = get_field_n(line, idx_manufacturer);
        if (manufacturer.empty()) continue;

        if (!(manufacturer == "Audi" || manufacturer == "BMW")) continue;

        // sale_date year check
        string sale_date = get_field_n(line, idx_date);
        if (sale_date.size() < 4 || !starts_with(sale_date, "2025")) continue;

        // 1. number of cars sold by 'Audi' in China in 2025
        if (manufacturer == "Audi") {
            string country = get_field_n(line, idx_country);
            if (country == "China") ++audi_china_2025;
            continue;
        }

        // 2. total revenue generated by 'BMW' in 2025
        string price_str = get_field_n(line, idx_price);
        long double price = 0.0L;
        if (!price_str.empty()) {
            char *endptr = nullptr;
            price = std::strtold(price_str.c_str(), &endptr);
            if (endptr == price_str.c_str()) {
                price = 0.0L;
            }
        }
        bmw_revenue_2025 += price;

        // 3. Distribution of BMW revenue in European countries from highest to lowest.
        string region = get_field_n(line, idx_region);
        if (region == "Europe") {
            string country = get_field_n(line, idx_country);
            if (country.empty()) country = "(unknown)";
            europe_revenue_by_country[country] += price;
        }
    }

    // Sort europe revenue descending
    vector<pair<string, long double>> europe_sorted;
    europe_sorted.reserve(europe_revenue_by_country.size());
    for (auto &p : europe_revenue_by_country) europe_sorted.emplace_back(p);
    sort(europe_sorted.begin(), europe_sorted.end(),
         [](auto &a, auto &b) { return a.second > b.second; });

    cout << "1. Audi cars sold in China in 2025 : " << audi_china_2025 << "\n";
    cout << "2. BMW total revenue in 2025: " << (double)bmw_revenue_2025 << "\n";
    cout << "3. BMW revenue distribution in Europe in 2025 (in descending order):\n";
    for (auto &kv : europe_sorted) {
        cout << "   " << kv.first << " : " << (double)kv.second << "\n";
    }
    return 0;
}
